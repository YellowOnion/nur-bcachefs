From 698223d31071d7b64c76ffc948e0fa6a6c499ddc Mon Sep 17 00:00:00 2001
From: Daniel Hill <daniel@gluo.nz>
Date: Fri, 6 Jan 2023 21:11:07 +1300
Subject: [PATCH] bcachefs: don't block reads if we're promoting

The promote path calls data_update_init() and now that we take locks here,
there's potential for promote to block our read path, just error
when we can't take the lock instead of blocking.

Signed-off-by: Daniel Hill <daniel@gluo.nz>
---
 fs/bcachefs/data_update.c | 26 +++++++++++++++++---------
 fs/bcachefs/errcode.h     |  1 +
 fs/bcachefs/io.c          |  7 +++++++
 3 files changed, 25 insertions(+), 9 deletions(-)

diff --git a/fs/bcachefs/data_update.c b/fs/bcachefs/data_update.c
index e764597428c7..c1da045a091f 100644
--- a/fs/bcachefs/data_update.c
+++ b/fs/bcachefs/data_update.c
@@ -403,6 +403,7 @@ int bch2_data_update_init(struct btree_trans *trans,
 	const union bch_extent_entry *entry;
 	struct extent_ptr_decoded p;
 	unsigned i, reserve_sectors = k.k->size * data_opts.extra_replicas;
+	unsigned int ptrs_locked = 0;
 	int ret;
 
 	bch2_bkey_buf_init(&m->k);
@@ -428,6 +429,8 @@ int bch2_data_update_init(struct btree_trans *trans,
 
 	i = 0;
 	bkey_for_each_ptr_decode(k.k, ptrs, p, entry) {
+		bool locked;
+
 		if (((1U << i) & m->data_opts.rewrite_ptrs) &&
 		    p.ptr.cached)
 			BUG();
@@ -452,11 +455,7 @@ int bch2_data_update_init(struct btree_trans *trans,
 		if (p.crc.compression_type == BCH_COMPRESSION_TYPE_incompressible)
 			m->op.incompressible = true;
 
-		i++;
-
 		if (ctxt) {
-			bool locked;
-
 			move_ctxt_wait_event(ctxt, trans,
 					(locked = bch2_bucket_nocow_trylock(&c->nocow_locks,
 								  PTR_BUCKET_POS(c, &p.ptr), 0)) ||
@@ -466,9 +465,14 @@ int bch2_data_update_init(struct btree_trans *trans,
 				bch2_bucket_nocow_lock(&c->nocow_locks,
 						       PTR_BUCKET_POS(c, &p.ptr), 0);
 		} else {
-			bch2_bucket_nocow_lock(&c->nocow_locks,
-					       PTR_BUCKET_POS(c, &p.ptr), 0);
+			if (!bch2_bucket_nocow_trylock(&c->nocow_locks,
+						       PTR_BUCKET_POS(c, &p.ptr), 0)) {
+				ret = -BCH_ERR_nocow_lock_blocked;
+				goto err;
+			}
 		}
+		ptrs_locked |= (1U << i);
+		i++;
 	}
 
 	if (reserve_sectors) {
@@ -490,9 +494,13 @@ int bch2_data_update_init(struct btree_trans *trans,
 		return -BCH_ERR_unwritten_extent_update;
 	return 0;
 err:
-	bkey_for_each_ptr_decode(k.k, ptrs, p, entry)
-		bch2_bucket_nocow_unlock(&c->nocow_locks,
-				       PTR_BUCKET_POS(c, &p.ptr), 0);
+	i = 0;
+	bkey_for_each_ptr_decode(k.k, ptrs, p, entry) {
+		if ((1U << i) & ptrs_locked)
+			bch2_bucket_nocow_unlock(&c->nocow_locks,
+						PTR_BUCKET_POS(c, &p.ptr), 0);
+		i++;
+	}
 
 	bch2_bkey_buf_exit(&m->k, c);
 	bch2_bio_free_pages_pool(c, &m->op.wbio.bio);
diff --git a/fs/bcachefs/errcode.h b/fs/bcachefs/errcode.h
index 6217096494e6..b8c24f517f03 100644
--- a/fs/bcachefs/errcode.h
+++ b/fs/bcachefs/errcode.h
@@ -118,6 +118,7 @@
 	x(BCH_ERR_invalid_sb,		invalid_sb_clean)			\
 	x(BCH_ERR_invalid_sb,		invalid_sb_quota)			\
 	x(BCH_ERR_invalid,		invalid_bkey)				\
+	x(BCH_ERR_operation_blocked,    nocow_lock_blocked)			\
 
 enum bch_errcode {
 	BCH_ERR_START		= 2048,
diff --git a/fs/bcachefs/io.c b/fs/bcachefs/io.c
index 2978ce85f8cf..430b853df628 100644
--- a/fs/bcachefs/io.c
+++ b/fs/bcachefs/io.c
@@ -1961,6 +1961,13 @@ static struct promote_op *__promote_alloc(struct btree_trans *trans,
 				.write_flags	= BCH_WRITE_ALLOC_NOWAIT|BCH_WRITE_CACHED,
 			},
 			btree_id, k);
+	if (ret == -BCH_ERR_nocow_lock_blocked) {
+		ret = rhashtable_remove_fast(&c->promote_table, &op->hash,
+					bch_promote_params);
+		BUG_ON(ret);
+		goto err;
+	}
+
 	BUG_ON(ret);
 	op->write.op.end_io = promote_done;
 
-- 
2.37.2

