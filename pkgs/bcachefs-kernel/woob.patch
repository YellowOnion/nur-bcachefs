From 1ced770287e07e0f2afa4169253dcb503ce5a0d9 Mon Sep 17 00:00:00 2001
From: Daniel Hill <daniel@gluo.nz>
Date: Tue, 10 Jan 2023 00:20:06 +1300
Subject: [PATCH 1/3] bcachefs: fix a path leak in bch2_make_extent_indirect

further investigation needed in to btree_path_put/get that might be
causing this leak in other places.

Signed-off-by: Daniel Hill <daniel@gluo.nz>

diff --git a/fs/bcachefs/reflink.c b/fs/bcachefs/reflink.c
index 87446f7bad4f..f74c659d86f9 100644
--- a/fs/bcachefs/reflink.c
+++ b/fs/bcachefs/reflink.c
@@ -189,7 +189,7 @@ static int bch2_make_extent_indirect(struct btree_trans *trans,
 
 	for_each_btree_key_norestart(trans, reflink_iter, BTREE_ID_reflink,
 			   POS(0, c->reflink_hint),
-			   BTREE_ITER_INTENT|BTREE_ITER_SLOTS, k, ret) {
+			   BTREE_ITER_SLOTS, k, ret) {
 		if (reflink_iter.pos.inode) {
 			bch2_btree_iter_set_pos(&reflink_iter, POS_MIN);
 			continue;
-- 
2.39.0


From b32bbeb4a26f28a4c2a2c6d1599c1816c1e0c7a2 Mon Sep 17 00:00:00 2001
From: Daniel Hill <daniel@gluo.nz>
Date: Sat, 14 Jan 2023 01:05:22 +1300
Subject: [PATCH 2/3] bcachefs: improve time_stats.

new time_stats points to give us more precise measurements of
various slow, problematic areas.

Signed-off-by: Daniel Hill <daniel@gluo.nz>

diff --git a/fs/bcachefs/bcachefs.h b/fs/bcachefs/bcachefs.h
index f51317337580..b76745842959 100644
--- a/fs/bcachefs/bcachefs.h
+++ b/fs/bcachefs/bcachefs.h
@@ -382,7 +382,13 @@ BCH_DEBUG_PARAMS_DEBUG()
 	x(blocked_journal)			\
 	x(blocked_allocate)			\
 	x(blocked_allocate_open_bucket)		\
-	x(nocow_lock_contended)
+	x(nocow_lock_contended)			\
+	x(btree_node_mem_alloc_lock)		\
+	x(btree_node_mem_alloc_got_node)	\
+	x(btree_node_mem_alloc_unlock)		\
+	x(btree_node_mem_alloc_got_mem)		\
+	x(journal_write_alloc)
+
 
 enum bch_time_stats {
 #define x(name) BCH_TIME_##name,
diff --git a/fs/bcachefs/btree_cache.c b/fs/bcachefs/btree_cache.c
index d10257e1a0bd..22a08c508a42 100644
--- a/fs/bcachefs/btree_cache.c
+++ b/fs/bcachefs/btree_cache.c
@@ -625,6 +625,8 @@ struct btree *bch2_btree_node_mem_alloc(struct bch_fs *c, bool pcpu_read_locks)
 	flags = memalloc_nofs_save();
 	mutex_lock(&bc->lock);
 
+	bch2_time_stats_update(&c->times[BCH_TIME_btree_node_mem_alloc_lock],
+			       start_time);
 	/*
 	 * We never free struct btree itself, just the memory that holds the on
 	 * disk node. Check the freed list before allocating a new one:
@@ -650,6 +652,8 @@ struct btree *bch2_btree_node_mem_alloc(struct bch_fs *c, bool pcpu_read_locks)
 	BUG_ON(!six_trylock_intent(&b->c.lock));
 	BUG_ON(!six_trylock_write(&b->c.lock));
 got_node:
+	bch2_time_stats_update(&c->times[BCH_TIME_btree_node_mem_alloc_got_node],
+			       start_time);
 
 	/*
 	 * btree_free() doesn't free memory; it sticks the node on the end of
@@ -667,12 +671,17 @@ struct btree *bch2_btree_node_mem_alloc(struct bch_fs *c, bool pcpu_read_locks)
 
 	mutex_unlock(&bc->lock);
 
+	bch2_time_stats_update(&c->times[BCH_TIME_btree_node_mem_alloc_unlock],
+			       start_time);
+
 	if (btree_node_data_alloc(c, b, __GFP_NOWARN|GFP_KERNEL))
 		goto err;
 
 	mutex_lock(&bc->lock);
 	bc->used++;
 got_mem:
+	bch2_time_stats_update(&c->times[BCH_TIME_btree_node_mem_alloc_got_mem],
+			       start_time);
 	mutex_unlock(&bc->lock);
 
 	BUG_ON(btree_node_hashed(b));
diff --git a/fs/bcachefs/journal_io.c b/fs/bcachefs/journal_io.c
index f6374a2bdc83..cd9c6dccdf5f 100644
--- a/fs/bcachefs/journal_io.c
+++ b/fs/bcachefs/journal_io.c
@@ -1380,6 +1380,7 @@ static int journal_write_alloc(struct journal *j, struct journal_buf *w,
 		c->opts.foreground_target;
 	unsigned i, replicas = 0, replicas_want =
 		READ_ONCE(c->opts.metadata_replicas);
+	u64 start_time = local_clock();
 
 	rcu_read_lock();
 retry:
@@ -1426,6 +1427,9 @@ static int journal_write_alloc(struct journal *j, struct journal_buf *w,
 done:
 	rcu_read_unlock();
 
+	bch2_time_stats_update(&c->times[BCH_TIME_journal_write_alloc],
+			       start_time);
+
 	BUG_ON(bkey_val_u64s(&w->key.k) > BCH_REPLICAS_MAX);
 
 	return replicas >= c->opts.metadata_replicas_required ? 0 : -EROFS;
-- 
2.39.0


From b8060a52c0aa2345494548a39a2f9c77ab8d9502 Mon Sep 17 00:00:00 2001
From: Daniel Hill <daniel@gluo.nz>
Date: Fri, 20 Jan 2023 01:27:30 +1300
Subject: [PATCH 3/3] bcachefs: let __bch2_btree_insert() pass in flags

This fixes a trigger running, and tripping up fsck when trying to repair
missing indirect extent.

Signed-off-by: Daniel Hill <daniel@gluo.nz>

diff --git a/fs/bcachefs/alloc_background.c b/fs/bcachefs/alloc_background.c
index 6fd948f11c0e..6fe46d3acc46 100644
--- a/fs/bcachefs/alloc_background.c
+++ b/fs/bcachefs/alloc_background.c
@@ -674,7 +674,7 @@ int bch2_bucket_gens_init(struct bch_fs *c)
 			ret = commit_do(&trans, NULL, NULL,
 					BTREE_INSERT_NOFAIL|
 					BTREE_INSERT_LAZY_RW,
-				__bch2_btree_insert(&trans, BTREE_ID_bucket_gens, &g.k_i));
+				__bch2_btree_insert(&trans, BTREE_ID_bucket_gens, &g.k_i, 0));
 			if (ret)
 				break;
 			have_bucket_gens_key = false;
@@ -694,7 +694,7 @@ int bch2_bucket_gens_init(struct bch_fs *c)
 		ret = commit_do(&trans, NULL, NULL,
 				BTREE_INSERT_NOFAIL|
 				BTREE_INSERT_LAZY_RW,
-			__bch2_btree_insert(&trans, BTREE_ID_bucket_gens, &g.k_i));
+			__bch2_btree_insert(&trans, BTREE_ID_bucket_gens, &g.k_i, 0));
 
 	bch2_trans_exit(&trans);
 
@@ -1934,7 +1934,7 @@ static int bch2_dev_freespace_init(struct bch_fs *c, struct bch_dev *ca)
 			freespace->k.p		= k.k->p;
 			freespace->k.size	= k.k->size;
 
-			ret = __bch2_btree_insert(&trans, BTREE_ID_freespace, freespace) ?:
+			ret = __bch2_btree_insert(&trans, BTREE_ID_freespace, freespace, 0) ?:
 				bch2_trans_commit(&trans, NULL, NULL,
 						  BTREE_INSERT_LAZY_RW|
 						  BTREE_INSERT_NOFAIL);
diff --git a/fs/bcachefs/btree_update.h b/fs/bcachefs/btree_update.h
index 673c3a78aae2..7ddebf90cddf 100644
--- a/fs/bcachefs/btree_update.h
+++ b/fs/bcachefs/btree_update.h
@@ -55,7 +55,8 @@ int bch2_btree_delete_extent_at(struct btree_trans *, struct btree_iter *,
 				unsigned, unsigned);
 int bch2_btree_delete_at(struct btree_trans *, struct btree_iter *, unsigned);
 
-int __bch2_btree_insert(struct btree_trans *, enum btree_id, struct bkey_i *);
+int __bch2_btree_insert(struct btree_trans *, enum btree_id, struct bkey_i *,
+			enum btree_update_flags);
 int bch2_btree_insert(struct bch_fs *, enum btree_id, struct bkey_i *,
 		     struct disk_reservation *, u64 *, int flags);
 
diff --git a/fs/bcachefs/btree_update_leaf.c b/fs/bcachefs/btree_update_leaf.c
index 6cbc0e5e1fe8..bc2decea1214 100644
--- a/fs/bcachefs/btree_update_leaf.c
+++ b/fs/bcachefs/btree_update_leaf.c
@@ -1614,7 +1614,8 @@ void bch2_trans_commit_hook(struct btree_trans *trans,
 }
 
 int __bch2_btree_insert(struct btree_trans *trans,
-			enum btree_id id, struct bkey_i *k)
+			enum btree_id id,
+			struct bkey_i *k, enum btree_update_flags flags)
 {
 	struct btree_iter iter;
 	int ret;
@@ -1622,7 +1623,7 @@ int __bch2_btree_insert(struct btree_trans *trans,
 	bch2_trans_iter_init(trans, &iter, id, bkey_start_pos(&k->k),
 			     BTREE_ITER_INTENT);
 	ret   = bch2_btree_iter_traverse(&iter) ?:
-		bch2_trans_update(trans, &iter, k, 0);
+		bch2_trans_update(trans, &iter, k, flags);
 	bch2_trans_iter_exit(trans, &iter);
 	return ret;
 }
@@ -1640,7 +1641,7 @@ int bch2_btree_insert(struct bch_fs *c, enum btree_id id,
 		      u64 *journal_seq, int flags)
 {
 	return bch2_trans_do(c, disk_res, journal_seq, flags,
-			     __bch2_btree_insert(&trans, id, k));
+			     __bch2_btree_insert(&trans, id, k, 0));
 }
 
 int bch2_btree_delete_extent_at(struct btree_trans *trans, struct btree_iter *iter,
diff --git a/fs/bcachefs/buckets.c b/fs/bcachefs/buckets.c
index ac0328c4f2c1..e36f018d0fd4 100644
--- a/fs/bcachefs/buckets.c
+++ b/fs/bcachefs/buckets.c
@@ -1220,7 +1220,8 @@ static s64 __bch2_mark_reflink_p(struct btree_trans *trans,
 		new->k.p		= bkey_start_pos(p.k);
 		new->k.p.offset += *idx - start;
 		bch2_key_resize(&new->k, next_idx - *idx);
-		ret = __bch2_btree_insert(trans, BTREE_ID_extents, &new->k_i);
+		ret = __bch2_btree_insert(trans, BTREE_ID_extents, &new->k_i,
+					  BTREE_TRIGGER_NORUN);
 	}
 
 	*idx = next_idx;
diff --git a/fs/bcachefs/fsck.c b/fs/bcachefs/fsck.c
index 5887d78190eb..52bb00b52b90 100644
--- a/fs/bcachefs/fsck.c
+++ b/fs/bcachefs/fsck.c
@@ -1797,7 +1797,8 @@ static int check_root_trans(struct btree_trans *trans)
 		ret = commit_do(trans, NULL, NULL,
 				      BTREE_INSERT_NOFAIL|
 				      BTREE_INSERT_LAZY_RW,
-			__bch2_btree_insert(trans, BTREE_ID_subvolumes, &root_subvol.k_i));
+			__bch2_btree_insert(trans, BTREE_ID_subvolumes,
+					    &root_subvol.k_i, 0));
 		if (ret) {
 			bch_err(c, "error writing root subvol: %s", bch2_err_str(ret));
 			goto err;
diff --git a/fs/bcachefs/tests.c b/fs/bcachefs/tests.c
index 80fce1c95470..d352821d5614 100644
--- a/fs/bcachefs/tests.c
+++ b/fs/bcachefs/tests.c
@@ -592,7 +592,7 @@ static int rand_insert(struct bch_fs *c, u64 nr)
 		k.k.p.snapshot = U32_MAX;
 
 		ret = commit_do(&trans, NULL, NULL, 0,
-			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k.k_i));
+			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k.k_i, 0));
 		if (ret) {
 			bch_err(c, "%s(): error %s", __func__, bch2_err_str(ret));
 			break;
@@ -621,14 +621,14 @@ static int rand_insert_multi(struct bch_fs *c, u64 nr)
 		}
 
 		ret = commit_do(&trans, NULL, NULL, 0,
-			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[0].k_i) ?:
-			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[1].k_i) ?:
-			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[2].k_i) ?:
-			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[3].k_i) ?:
-			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[4].k_i) ?:
-			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[5].k_i) ?:
-			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[6].k_i) ?:
-			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[7].k_i));
+			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[0].k_i, 0) ?:
+			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[1].k_i, 0) ?:
+			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[2].k_i, 0) ?:
+			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[3].k_i, 0) ?:
+			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[4].k_i, 0) ?:
+			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[5].k_i, 0) ?:
+			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[6].k_i, 0) ?:
+			__bch2_btree_insert(&trans, BTREE_ID_xattrs, &k[7].k_i, 0));
 		if (ret) {
 			bch_err(c, "%s(): error %s", __func__, bch2_err_str(ret));
 			break;
-- 
2.39.0

