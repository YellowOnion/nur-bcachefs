From 39dde8aa7df9b6da5b4623a80ee23d8a259ca5aa Mon Sep 17 00:00:00 2001
From: Daniel Hill <daniel@gluo.nz>
Date: Fri, 6 Jan 2023 21:11:07 +1300
Subject: [PATCH 1/3] bcachefs: don't block reads if we're promoting

The promote path calls data_update_init() and now that we take locks here,
there's potential for promote to block our read path, just error
when we can't take the lock instead of blocking.

Signed-off-by: Daniel Hill <daniel@gluo.nz>
---
 fs/bcachefs/data_update.c | 26 +++++++++++++++++---------
 fs/bcachefs/errcode.h     |  1 +
 fs/bcachefs/io.c          |  7 +++++++
 3 files changed, 25 insertions(+), 9 deletions(-)

diff --git a/fs/bcachefs/data_update.c b/fs/bcachefs/data_update.c
index 259bd243fc5b..863b797d163e 100644
--- a/fs/bcachefs/data_update.c
+++ b/fs/bcachefs/data_update.c
@@ -413,6 +413,7 @@ int bch2_data_update_init(struct btree_trans *trans,
 	const union bch_extent_entry *entry;
 	struct extent_ptr_decoded p;
 	unsigned i, reserve_sectors = k.k->size * data_opts.extra_replicas;
+	unsigned int ptrs_locked = 0;
 	int ret;
 
 	bch2_bkey_buf_init(&m->k);
@@ -438,6 +439,8 @@ int bch2_data_update_init(struct btree_trans *trans,
 
 	i = 0;
 	bkey_for_each_ptr_decode(k.k, ptrs, p, entry) {
+		bool locked;
+
 		if (((1U << i) & m->data_opts.rewrite_ptrs) &&
 		    p.ptr.cached)
 			BUG();
@@ -463,11 +466,7 @@ int bch2_data_update_init(struct btree_trans *trans,
 		if (p.crc.compression_type == BCH_COMPRESSION_TYPE_incompressible)
 			m->op.incompressible = true;
 
-		i++;
-
 		if (ctxt) {
-			bool locked;
-
 			move_ctxt_wait_event(ctxt, trans,
 					(locked = bch2_bucket_nocow_trylock(&c->nocow_locks,
 								  PTR_BUCKET_POS(c, &p.ptr), 0)) ||
@@ -477,9 +476,14 @@ int bch2_data_update_init(struct btree_trans *trans,
 				bch2_bucket_nocow_lock(&c->nocow_locks,
 						       PTR_BUCKET_POS(c, &p.ptr), 0);
 		} else {
-			bch2_bucket_nocow_lock(&c->nocow_locks,
-					       PTR_BUCKET_POS(c, &p.ptr), 0);
+			if (!bch2_bucket_nocow_trylock(&c->nocow_locks,
+						       PTR_BUCKET_POS(c, &p.ptr), 0)) {
+				ret = -BCH_ERR_nocow_lock_blocked;
+				goto err;
+			}
 		}
+		ptrs_locked |= (1U << i);
+		i++;
 	}
 
 	if (reserve_sectors) {
@@ -501,9 +505,13 @@ int bch2_data_update_init(struct btree_trans *trans,
 		return -BCH_ERR_unwritten_extent_update;
 	return 0;
 err:
-	bkey_for_each_ptr_decode(k.k, ptrs, p, entry)
-		bch2_bucket_nocow_unlock(&c->nocow_locks,
-				       PTR_BUCKET_POS(c, &p.ptr), 0);
+	i = 0;
+	bkey_for_each_ptr_decode(k.k, ptrs, p, entry) {
+		if ((1U << i) & ptrs_locked)
+			bch2_bucket_nocow_unlock(&c->nocow_locks,
+						PTR_BUCKET_POS(c, &p.ptr), 0);
+		i++;
+	}
 
 	bch2_bkey_buf_exit(&m->k, c);
 	bch2_bio_free_pages_pool(c, &m->op.wbio.bio);
diff --git a/fs/bcachefs/errcode.h b/fs/bcachefs/errcode.h
index 6217096494e6..b8c24f517f03 100644
--- a/fs/bcachefs/errcode.h
+++ b/fs/bcachefs/errcode.h
@@ -118,6 +118,7 @@
 	x(BCH_ERR_invalid_sb,		invalid_sb_clean)			\
 	x(BCH_ERR_invalid_sb,		invalid_sb_quota)			\
 	x(BCH_ERR_invalid,		invalid_bkey)				\
+	x(BCH_ERR_operation_blocked,    nocow_lock_blocked)			\
 
 enum bch_errcode {
 	BCH_ERR_START		= 2048,
diff --git a/fs/bcachefs/io.c b/fs/bcachefs/io.c
index 2978ce85f8cf..430b853df628 100644
--- a/fs/bcachefs/io.c
+++ b/fs/bcachefs/io.c
@@ -1961,6 +1961,13 @@ static struct promote_op *__promote_alloc(struct btree_trans *trans,
 				.write_flags	= BCH_WRITE_ALLOC_NOWAIT|BCH_WRITE_CACHED,
 			},
 			btree_id, k);
+	if (ret == -BCH_ERR_nocow_lock_blocked) {
+		ret = rhashtable_remove_fast(&c->promote_table, &op->hash,
+					bch_promote_params);
+		BUG_ON(ret);
+		goto err;
+	}
+
 	BUG_ON(ret);
 	op->write.op.end_io = promote_done;
 
-- 
2.37.2


From 79f0f5e247f14e35c1a10d48f9aa955a70c79a14 Mon Sep 17 00:00:00 2001
From: Daniel Hill <daniel@gluo.nz>
Date: Mon, 9 Jan 2023 01:49:42 +1300
Subject: [PATCH 2/3] bcachefs: add tracepoint for bch2_alloc_sectors_trans()

Signed-off-by: Daniel Hill <daniel@gluo.nz>
---
 fs/bcachefs/alloc_foreground.c  | 31 ++++++++++++++++++++++++++++++-
 include/trace/events/bcachefs.h | 13 +++++++++++++
 2 files changed, 43 insertions(+), 1 deletion(-)

diff --git a/fs/bcachefs/alloc_foreground.c b/fs/bcachefs/alloc_foreground.c
index badf1075c9bf..de48c58a1f0e 100644
--- a/fs/bcachefs/alloc_foreground.c
+++ b/fs/bcachefs/alloc_foreground.c
@@ -1129,7 +1129,7 @@ static struct write_point *writepoint_find(struct btree_trans *trans,
 /*
  * Get us an open_bucket we can allocate from, return with it locked:
  */
-struct write_point *bch2_alloc_sectors_start_trans(struct btree_trans *trans,
+struct write_point *__bch2_alloc_sectors_start_trans(struct btree_trans *trans,
 				unsigned target,
 				unsigned erasure_code,
 				struct write_point_specifier write_point,
@@ -1240,7 +1240,36 @@ struct write_point *bch2_alloc_sectors_start_trans(struct btree_trans *trans,
 
 	return ERR_PTR(ret);
 }
+struct write_point *bch2_alloc_sectors_start_trans(struct btree_trans *trans,
+				unsigned target,
+				unsigned erasure_code,
+				struct write_point_specifier write_point,
+				struct bch_devs_list *devs_have,
+				unsigned nr_replicas,
+				unsigned nr_replicas_required,
+				enum alloc_reserve reserve,
+				unsigned flags,
+				struct closure *cl)
+{
+	struct write_point *wp;
+	int ret;
 
+	wp = __bch2_alloc_sectors_start_trans(trans,
+					      target,
+					      erasure_code,
+					      write_point,
+					      devs_have,
+					      nr_replicas,
+					      nr_replicas_required,
+					      reserve,
+					      flags,
+					      cl);
+	ret = PTR_ERR_OR_ZERO(wp);
+
+	trace_alloc_sector_trans(trans->c, bch2_err_str(ret), bch2_err_matches(ret, BCH_ERR_transaction_restart));
+
+	return wp;
+}
 struct bch_extent_ptr bch2_ob_ptr(struct bch_fs *c, struct open_bucket *ob)
 {
 	struct bch_dev *ca = bch_dev_bkey_exists(c, ob->dev);
diff --git a/include/trace/events/bcachefs.h b/include/trace/events/bcachefs.h
index f699146aad26..78a4f1abfc27 100644
--- a/include/trace/events/bcachefs.h
+++ b/include/trace/events/bcachefs.h
@@ -656,6 +656,19 @@ TRACE_EVENT(bucket_invalidate,
 		  __entry->sectors)
 );
 
+TRACE_EVENT(alloc_sector_trans,
+	TP_PROTO(struct bch_fs *c, const char * err, bool restart),
+	TP_ARGS(c, err, restart),
+	TP_STRUCT__entry(
+		    __array(char, err, 32)
+		    __field(bool, restart)
+	),
+	TP_fast_assign(
+		    strscpy(__entry->err, err, sizeof(__entry->err));
+		    __entry->restart = restart;
+	),
+	TP_printk("err %s restart %s", __entry->err, __entry->restart ? "true" : "false")
+);
 /* Moving IO */
 
 DEFINE_EVENT(bkey, move_extent_read,
-- 
2.37.2


From 267abbd2e0465ab33456379bbf4271ebd12962cb Mon Sep 17 00:00:00 2001
From: Daniel Hill <daniel@gluo.nz>
Date: Mon, 9 Jan 2023 12:47:11 +1300
Subject: [PATCH 3/3] fixup! bcachefs: Convert EAGAIN errors to private error
 codes

Signed-off-by: Daniel Hill <daniel@gluo.nz>
---
 fs/bcachefs/io.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/fs/bcachefs/io.c b/fs/bcachefs/io.c
index 430b853df628..6f9715729d66 100644
--- a/fs/bcachefs/io.c
+++ b/fs/bcachefs/io.c
@@ -1638,9 +1638,10 @@ static void __bch2_write(struct closure *cl)
 				? NULL : cl)));
 		ret = PTR_ERR_OR_ZERO(wp);
 		if (unlikely(ret)) {
-			if (bch2_err_matches(ret, BCH_ERR_operation_blocked))
-				break;
-
+			if (!bch2_err_matches(ret, BCH_ERR_operation_blocked)) {
+				op->error = PTR_ERR(wp);
+				op->flags |= BCH_WRITE_DONE;
+			}
 			break;
 		}
 
-- 
2.37.2

